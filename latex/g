113292475659649136992	1456600612040	Initialise UMI	\\section{Definition - Inline Describer Syntax}\n\nGiven any variable $x$, any term $t$ and any well formed formula $\\phi$ where $x$ is free in $\\phi$ we can evaluate the truth of\n\n$$t = \\{ x \\text{ where } \\phi(x), $$\n\nif and only if \n\n$$\\exists y \\, \\phi(y) \\wedge \\forall z \\, \\phi(z) \\rightarrow z = y$$\n\nI.e. there exists a {\\it unique} $y$ such that $\\phi(y)$. Then we evaluate \"$t = \\{ x \\text{ where } \\phi(x), $\" to be true if and only if $\\phi(t)$.\n\n\\section{Examples}\n\nIn set theory a function is actually defined as a set of pairs, so given a function $f$ say, then $f(x) := \\{ y \\text{ where } (x, y) \\in f$.\\par\n\nThis definition of {\\id=3 Set Builder Notation} is also a good example.\n\n\\section{Motivation}\n\nA very common pattern in mathematics, and language in general, is to use a statement (i.e. a well-formed-formula) with a single free variable in place of a term to mean the unique term that satisfies that statement.\\par\n\nFor example \"I like the red cat\"; we are implying that a red cat exists and in this context there is only one red cat. So strictly speaking it means \"There exists a red cat and there is only one red cat, and that is the cat I like\".  \nIn fact if two red cats or no red cats exist in the context then one would argue that the statement doesn't even \"make sense\".  \nIndeed the grammar is correct, but the {\\bf evaluation of truth} does not really make sense.  \nSuppose ten red cats are in a room and Alice states that she \"likes the red cat\", then the natural response of Bob would be not to consider the statement false say, Bob would not assume \"Alice is wrong, she does not like the red cat for there are many red cats\".  \nBob would more likely respond along the lines of \"what red cat?\", that is not consider it possible to evaluate the truth of the statement.\\par\n\nThere is some \"meta-English\" process that is being done prior to evaluating truth, first the existence and uniqueness of a red cat needs to be established.  This is not to be confused with a meta-English statement, since the statement is not a statement about English.\\par\n\nThis pattern allows humans to communicate incredibly concisely, but at the cost of sometimes not making sense and adding an extra layer of complexity to the evaluation of truth.  \nWe can simply divide evaluation of truth as first {\\it parsing} some {\\bf Syntax} followed by applying rules of proof to establish a proof in order to evaluate {\\bf Truth}.  \nThis neat construction adds an intermediate layer where we must use the same rules of proof to first prove a statement that's truth determines whether the actual evaluation of truth is possible.\\par\n\nTherefore we decided to include this special syntax, and extra layer of complexity in the language so that the language is as expressive as possible.\nThis is making the implementation of the proof checker much harder, but will mean that formal proofs can be substantially terser and easier to understand.\nThis is after all an ambition of OpenMaths, to be able to formally check mathematics that is as easy to read as informal mathematics.\n\n\\section{Types}\n\nThe above is a specific syntax for a quite general concept, a concept common place in programming languages, and natural language, but less explicitly explored in Mathematics.  \nIt is the concept of \"types\". For example suppose Alice said \"I like red sounds\", again Bob would naturally not evaluate this statement to be true nor false.\nBob would know the {\\bf types} of things that can have colour do not include sounds, the statement just doesn't make sense even though it's grammatically correct.\\par\n\nIn ordinary informal mathematics mathematicians use types without thinking, but in traditional formal mathematics they are less common because they make automatic checking much harder.\\par\n\n\\section{Definition - Type}\n\nA {\\bf type} is a well formed formula $\\phi$ with a single free variable, that when used along with an \"annotation syntax\" that annotates a term $t$ to \"have this type\" implies the truth of the containing statement cannot be established until first it's proved that $\\phi(t)$.\\par\n\nFor example in many programming languages the syntax $x : T$ means $x$ is a $T$ or has type $T$, e.g. $\\exists x : \\mathbb{N}, x + 2 = 5$. In informal mathematics we abuse notation and reuse the $\\in$ symbol to mean $:$.\\par\n\nFurthermore we can {\\it type} a notation so that usage of that notation only makes sense when the subjects of the notation have the required types. \nThe classic example being functions, like the $+$ operator (or function), we consider $\\{3, 4, 5\\} + (10, 15)$ to not make sense, while $4 + 5$ does.\\par\n\nThe {\\bf Inline Describer Syntax} can pretty much provide most of the type annotation ability we need.  When using OpenMaths it ought to become clear how notation can become \"typed\".  \nAnnotations directly on variables at declaration, or various other ways to annotate types seen in programming languages, are not yet implemented, but will soon! Our priority is to finish the proof check which will actually be using the types before implementing more type systems.
