113292475659649136992	1456596972917	Initialise UMI	The biggest challenge to designing the language so that any valid natural mathematical sentence can some day be checked by a computer is to build in completely unrestricted means of introducing notation, definitions and patterns of proof.  \nNatural mathematics often switches from technically \"meta\" mathematics, like the Axiom Schema of Specification or introducing some notation, and use of that Schema or notation.  \nThis means that the unrestricted introduction of abstraction also needs to be possible at a meta-level too.\n\n\\section{Arbitrary Macro Support and Automatic Inference}\n\nTo solve the first problem we provide a native meta-mathematical language for the introduction of abstractions via macros where those macros are inferred in the same way humans infer what is new syntax.\nA nice example of this is {\\id=3 Set Builder Notation}, in this example the native constructs are $\\text{Wff}$, $\\text{Var}$ and $\\{ \\_ \\text{ where } \\_$.\nThe macro is $\\{ x | \\phi \\}$, note how escaping is not required and using this macro doesn't require any extra syntax (just add it to the prerequisites).\nThis macro system is a little like the language Lisp, except in Lisp huge reams of parenthesis are needed to both define and use macros.\n\n\\section{Meta-Macros}\n\nNow to solve the second problem we allow the introduction of meta-mathematical macros using the same native notation.\nAn example of this is the {\\id=0 alias alias} for the native symbol $:=$. That is we need not write $:=(x, y)$ we can write $x := y$ when {\\it aliasing/defining} notation. Hence we have a meta-macro that can change the very way we introduce macros.\nThis means if you would prefer to write the definition of set builder notation like this:\\par\n\n$\\text{for any formula } \\phi, \\text{ for any variable } x, \\text{ we write } \\{ x | \\phi \\} \\text{ to mean } ``\\{ y \\text{ where } \\forall x (x \\in y \\leftrightarrow \\phi), \" $\\par\n\nYou can, you would just need to write some meta-macros first.  Over time such macros will already exist.  \nThe only current caveat with usage is that you have to add the macros you are using to the list of Prerequisite Definitions.\nSo we could easily add a feature that searches through macros in some sensible way trying to find one that would make your maths \"compile\".\n\n\\section{Quoting}\n\nWe currently have just a single limitation on what kind of notation is possible, that is quotes are required when you are introducing syntax that includes a logical symbol, or the substitution includes logical symbols.\nIf this limitation bothers users then we could perhaps introduce an invisible syntax, like \\\\hspace\\{0cm\\}, or our own abbreviation of this.  \nIt is possible not to require any syntax at all and the compiler could just infer what is meant, but we believe the kind of error messages produced when people make mistakes would become obstructively confusing.\nWe may allow a switch for users to turn on such a feature at their own risk.\n\n\\section{The Big Catch - Why this has not been done before}\n\nAs mentioned earlier some programming languages do have quite powerful macro systems, i.e. Lisp, but require the macro to be contained inside parenthesis.\nThis means code becomes unreadable fairly quickly.  So why did they require this restriction?\nThe issue is compile speed.  \nNearly all programming languages are close to a family of grammars called Context-Free Grammars (CFGs), which can be compiled in polynomial time and in many cases linear time. \nNow if a language doesn't belong in this family but has no restrictions it can take exponential time to compile.\nThis is indeed the case for the OpenMaths language design.\\par\n\nDoes this mean OpenMaths will become prohibitively slow? No, and in a nutshell the reason for this is that the compiler exists on the cloud and there exists only one single \"monorepo\" with all the code in it.\nThis means we can make certain optimisations, tricks and choices that ordinarily wouldn't work in the regular programming world.\\par\n\nIn essence then, the only catch is that OpenMaths will be web-based for the foreseeable future, but since the internet is now so fast and easily accessible this is unlikely to bother people.\nNevertheless a distributed version of OpenMaths has been conceptualized based on Block Chain technology, though this is unlikely to be a priority.
